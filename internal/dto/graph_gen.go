// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package dto

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type Mutation struct {
}

type Offer struct {
	Name  string  `json:"name"`
	Price float64 `json:"price"`
}

type Plan struct {
	ID           string    `json:"id"`
	Name         string    `json:"name"`
	Price        float64   `json:"price"`
	MaxDailyScan int       `json:"maxDailyScan"`
	CreatedAt    time.Time `json:"created_at"`
	Creator      *User     `json:"creator,omitempty"`
}

type PlanInput struct {
	Name         string  `json:"name"`
	Price        float64 `json:"price"`
	MaxDailyScan int     `json:"maxDailyScan"`
}

type ProductID struct {
	ID   string        `json:"id"`
	Type ProductIDType `json:"type"`
}

type ProductIDInput struct {
	ID   string        `json:"id"`
	Type ProductIDType `json:"type"`
}

type ProductInfo struct {
	ID         string        `json:"id"`
	Type       ProductIDType `json:"type"`
	Title      string        `json:"title"`
	Price      *float64      `json:"price,omitempty"`
	SellerName *string       `json:"sellerName,omitempty"`
	Offers     []*Offer      `json:"offers,omitempty"`
}

type Query struct {
}

type ScanRequest struct {
	ID       string       `json:"id"`
	User     *User        `json:"user"`
	Products []*ProductID `json:"products"`
}

type ScanRequestInput struct {
	Products []*ProductIDInput `json:"products"`
}

type ScannedProductInfo struct {
	LeftProductInfo  *ProductInfo `json:"leftProductInfo"`
	RightProductInfo *ProductInfo `json:"rightProductInfo"`
	Profit           float64      `json:"profit"`
}

type SortBy struct {
	Field string `json:"field"`
	Order Order  `json:"order"`
}

type User struct {
	ID        string    `json:"id"`
	Email     string    `json:"email"`
	AvatarID  *int      `json:"avatarID,omitempty"`
	CreatedAt time.Time `json:"created_at"`
	Plan      *UserPlan `json:"plan"`
}

type UserInput struct {
	Email    string  `json:"email"`
	Password *string `json:"password,omitempty"`
	AvatarID *int    `json:"avatarID,omitempty"`
}

type UserPlan struct {
	ID           string     `json:"id"`
	User         *User      `json:"user"`
	SelectedPlan *Plan      `json:"selectedPlan,omitempty"`
	StartAt      *time.Time `json:"startAt,omitempty"`
	EndAt        *time.Time `json:"endAt,omitempty"`
}

type Order string

const (
	OrderAsc  Order = "ASC"
	OrderDesc Order = "DESC"
)

var AllOrder = []Order{
	OrderAsc,
	OrderDesc,
}

func (e Order) IsValid() bool {
	switch e {
	case OrderAsc, OrderDesc:
		return true
	}
	return false
}

func (e Order) String() string {
	return string(e)
}

func (e *Order) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Order(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Order", str)
	}
	return nil
}

func (e Order) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProductIDType string

const (
	ProductIDTypeUpc ProductIDType = "UPC"
	ProductIDTypeEan ProductIDType = "EAN"
)

var AllProductIDType = []ProductIDType{
	ProductIDTypeUpc,
	ProductIDTypeEan,
}

func (e ProductIDType) IsValid() bool {
	switch e {
	case ProductIDTypeUpc, ProductIDTypeEan:
		return true
	}
	return false
}

func (e ProductIDType) String() string {
	return string(e)
}

func (e *ProductIDType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductIDType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductIDType", str)
	}
	return nil
}

func (e ProductIDType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
